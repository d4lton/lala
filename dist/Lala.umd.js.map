{"version":3,"file":null,"sources":["../src/ParseError.js","../src/Parser.js","../src/Lexer.js","../src/InterpretError.js","../src/Interpreter.js","../src/Lala.js"],"sourcesContent":["/**\n * Hemp\n *\n * Copyright ©2017 Dana Basken <dbasken@gmail.com>\n *\n */\nfunction ParseError(message, token, expected) {\n  this.message = message;\n  this.token = token;\n  this.expected = expected;\n};\nParseError.prototype = new Error;\n\nexport default ParseError;\n","/**\n * Hemp\n *\n * Copyright ©2017 Dana Basken <dbasken@gmail.com>\n *\n */\nimport ParseError from './ParseError.js';\n\nclass Parser {\n\n  constructor(grammar, lexer) {\n    this.grammar = grammar;\n    this.lexer = lexer;\n    this.token = this.lexer.nextToken();\n  };\n\n  reset() {\n    this.lexer.reset();\n    this.token = this.lexer.nextToken();\n  };\n\n  cloneCurrentToken() {\n    return JSON.parse(JSON.stringify(this.token));\n  };\n\n  eat(type, value) {\n    if (this.token.type == type && ((typeof value !== 'undefined') ? (this.token.value == value) : true)) {\n      this.token = this.lexer.nextToken();\n    } else {\n      if (typeof value !== 'undefined') {\n        throw new ParseError('Expected ' + type + ': \"' + value + '\"', this.cloneCurrentToken(), {type: type, value: value});\n      } else {\n        throw new ParseError('Expected ' + type, this.cloneCurrentToken(), {type: type});\n      }\n    }\n  };\n\n  factor() {\n    var token = this.cloneCurrentToken();\n    if (token.type == 'number') {\n      this.eat(token.type);\n      return {\n        type: 'NumericConstant',\n        value: token.value,\n        start: token.start,\n        end: token.end\n      };\n    } else if (token.type == \"string\") {\n      this.eat(token.type);\n      return {\n        type: 'StringConstant',\n        value: token.value,\n        start: token.start,\n        end: token.end\n      };\n    } else if (token.type == 'identifier') {\n      this.eat(token.type);\n      var type = 'Variable';\n      if (token.value == 'true' || token.value == 'false') {\n        type = 'BooleanConstant';\n        token.value = (token.value == 'true') ? true : false;\n      }\n      return {\n        type: type,\n        value: token.value,\n        start: token.start,\n        end: token.end\n      }\n    } else if (token.type == 'parenthesis') {\n      this.eat(token.type, '(');\n      var result = this.expression();\n      this.eat('parenthesis', ')');\n      return result;\n    } else if (token.type == 'braces') {\n      this.eat(token.type, '{');\n      var result = this.block();\n      this.eat('braces', '}');\n      return result;\n    } else {\n      throw new ParseError('Expected an expression', token);\n    }\n  };\n\n  makeTermNode(type, node) {\n    var token = this.cloneCurrentToken();\n    this.eat(this.token.type);\n    return {\n      type: type,\n      left: node,\n      operator: token.value,\n      right: this.factor(),\n      start: token.start,\n      end: token.end\n    };\n  };\n\n  term() {\n\n    var node = this.factor();\n\n    var foundOperator = false;\n    do {\n      foundOperator = false;\n      for (var i = 0; i < this.grammar.operators.length; i++) {\n        while (this.token && this.token.type === 'operator' && this.token.value === this.grammar.operators[i].value) {\n          node = this.makeTermNode(this.grammar.operators[i].result, node);\n          foundOperator = true;\n        }\n      }\n    } while (foundOperator);\n\n    return node;\n\n  };\n\n  expression() {\n\n/*\n    var node = this.term();\n\n    if (this.token) {\n    for (var i = 0; i < this.grammar.expressions.length; i++) {\n      var rules = this.grammar.expressions[i].rules;\n      if (rules && rules.length > 0) {\n        if (rules[0].type === this.token.type && rules[0].values.indexOf(this.token.value) !== -1) {\n          var node = {\n            type: this.grammar.expressions[i].result,\n            value: this.token.value,\n            start: this.token.start,\n            end: this.token.end\n          };\n          for (var j = 0; j < rules.length; j++) {\n            var rule = rules[j];\n            if (rule.optional === true && (!this.token || this.token.type != rule.type)) {\n              break;\n            }\n            if (rule.parse) {\n              node[rule.result] = this[rule.parse]();\n            } else {\n              this.eat(rule.type, rule.value);\n            }\n          }\n          return node;\n        }\n      }\n    }\n    }\n    return node;\n    */\n\n\n    for (var i = 0; i < this.grammar.expressions.length; i++) {\n      var rules = this.grammar.expressions[i].rules;\n      if (rules && rules.length > 0) {\n        if (rules[0].type === this.token.type && rules[0].values.indexOf(this.token.value) !== -1) {\n          var node = {\n            type: this.grammar.expressions[i].result,\n            value: this.token.value,\n            start: this.token.start,\n            end: this.token.end\n          };\n          for (var j = 0; j < rules.length; j++) {\n            var rule = rules[j];\n            if (rule.optional === true && (!this.token || this.token.type != rule.type)) {\n              break;\n            }\n            if (rule.parse) {\n              node[rule.result] = this[rule.parse]();\n            } else {\n              this.eat(rule.type, rule.value);\n            }\n          }\n          return node;\n        }\n      }\n    }\n\n    return this.term();\n\n  };\n\n  block() {\n\n    var node = {\n      type: 'Block',\n      nodes: []\n    };\n\n    while (this.token && this.token.type !== 'braces' && this.token.value !== '}') {\n      node.nodes.push(this.expression());\n    }\n\n    return node;\n  };\n\n  program() {\n    var nodes = [];\n    while (this.token) {\n      nodes.push(this.expression());\n    };\n    return nodes;\n  };\n\n  parse() {\n    this.reset();\n    return this.program();\n  };\n\n};\n\nexport default Parser;\n","/**\n * Hemp\n *\n * Copyright ©2017 Dana Basken <dbasken@gmail.com>\n *\n */\nclass Lexer {\n\n  constructor(lexicon, text) {\n    this.lexicon = lexicon;\n    this.text = text;\n    this.pos = -1;\n  }\n\n  reset() {\n    this.pos = -1;\n  };\n\n  next() {\n    if (!this.end()) {\n      this.pos++;\n      this.current = this.text[this.pos];\n      return this.current;\n    }\n  };\n\n  peek() {\n    return this.text[this.pos + 1];\n  };\n\n  end() {\n    return (this.pos >= (this.text.length - 1));\n  };\n\n  scanstring(lex) {\n    var result = ''; // ignore the initial quotation mark\n    // TODO: should check for escaped quotation marks\n    while ((typeof this.peek() !== 'undefined') && this.peek() !== '\"') {\n      result += this.next();\n    }\n    this.next(); // eat the final quotation mark\n    return result;\n  };\n\n  scan(lex) {\n    var result = this.current;\n    if (lex.scanner) {\n      return this['scan' + lex.scanner](lex);\n    }\n    if (lex.test) {\n      while ((typeof this.peek() !== 'undefined') && lex.test.test(this.peek())) {\n        result += this.next();\n      };\n      if (lex.keepLast === true) {\n        result += this.next();\n      }\n    }\n    return result;\n  };\n\n  getToken() {\n    if (!this.end()) {\n      var c = this.next();\n      var types = Object.keys(this.lexicon);\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i];\n        if (this.lexicon[type].startTest.test(c)) {\n          var start = this.pos;\n          var value = this.scan(this.lexicon[type]);\n          if (this.lexicon[type].values && this.lexicon[type].values.indexOf(value) === -1) {\n            throw new Error(value + ' token matches ' + type + ' regex, but not one of ' + this.lexicon[type].values.join(','));\n          }\n          return {\n            start: start,\n            end: this.pos,\n            type: type,\n            value: value\n          }\n        }\n      }\n      throw new Error('could not match: ' + c);\n    }\n  };\n\n  nextToken() {\n    var token = this.getToken();\n    while (token && token.type == 'ignore') {\n      token = this.getToken();\n    }\n    return token;\n  };\n\n  allTokens() {\n    var results = [];\n    var token = this.nextToken();\n    while (token) {\n      results.push(token);\n      token = this.nextToken();\n    }\n    return results;\n  };\n\n};\n\nexport default Lexer;\n","/**\n * Hemp\n *\n * Copyright ©2017 Dana Basken <dbasken@gmail.com>\n *\n */\nfunction InterpretError(message, node) {\n  this.message = message;\n  this.node = node;\n};\nInterpretError.prototype = new Error;\n\nexport default InterpretError;\n","/**\n * Hemp\n *\n * Copyright ©2017 Dana Basken <dbasken@gmail.com>\n *\n */\nimport Parser from './Parser.js';\nimport InterpretError from './InterpretError.js';\n\nclass Interpreter {\n\n  constructor(parser) {\n    this.parser = parser;\n  };\n  \n  visitBooleanConstant(node) {\n    return node.value;\n  };\n\n  visitNativeFunction(node) {\n    switch (node.value) {\n      case 'now':\n        return Date.now();\n        break;\n      case 'day':\n        var date = new Date();\n        return ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][date.getDay()];\n        break;\n      case 'month':\n        var date = new Date();\n        return ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'Auguest', 'September', 'October', 'November', 'December'][date.getMonth()];\n        break;\n      case 'year':\n        var date = new Date();\n        return date.getFullYear()\n        break;\n      default:\n         throw new InterpretError('Unknown native function: ' + node.value, node);\n        break;\n    };\n  };\n\n  visitCallStatement(node) {\n    if (typeof this.callback === 'function') {\n      this.callback(node.value);\n    }\n  };\n\n  visitBlock(node) {\n    var result;\n    node.nodes.forEach(function(root) {\n      result = this.visit(root);\n    }.bind(this));\n    return result;\n  };\n\n  visitNumericConstant(node) {\n    return parseFloat(node.value);\n  };\n\n  visitStringConstant(node) {\n    return node.value;\n  };\n\n  visitVariable(node) {\n\n      var properties = node.value.split('.');\n      var object = this.variables;\n      properties.forEach(function(property) {\n        if (typeof object[property] === 'undefined') {\n          throw new InterpretError('Unknown identifier: ' + node.value, node);\n        }\n        object = object[property];\n      });\n      return object;\n\n  };\n\n  visitMathExpression(node) {\n    if (node.operator === '+') {\n      return this.visit(node.left) + this.visit(node.right);\n    }\n    if (node.operator === '-') {\n      return this.visit(node.left) - this.visit(node.right);\n    }\n    if (node.operator === '*') {\n      return this.visit(node.left) * this.visit(node.right);\n    }\n    if (node.operator === '-') {\n      return this.visit(node.left) - this.visit(node.right);\n    }\n    throw new InterpretError('Uknown operator: ' + node.operator, node);\n  };\n\n  visitAssignmentExpression(node) {\n    var value = this.visit(node.right);\n    if (!isNaN(value) && (typeof value !== 'boolean')) {\n      value = parseFloat(value);\n    }\n    var properties = node.left.value.split('.');\n    var object = this.variables;\n    properties.forEach(function(property, index) {\n      if (index == properties.length - 1) {\n        object[property] = value;\n      } else {\n        if (typeof object[property] === 'undefined') {\n          object[property] = {};\n        }\n        object = object[property];\n      }\n    });\n    return value;\n  };\n\n  visitComparisonExpression(node) {\n    if (node.operator === '==') {\n      return this.visit(node.left) == this.visit(node.right);\n    }\n    if (node.operator === '!=') {\n      return this.visit(node.left) != this.visit(node.right);\n    }\n    if (node.operator === '<=') {\n      return this.visit(node.left) <= this.visit(node.right);\n    }\n    if (node.operator === '>=') {\n      return this.visit(node.left) >= this.visit(node.right);\n    }\n    if (node.operator === '<') {\n      return this.visit(node.left) < this.visit(node.right);\n    }\n    if (node.operator === '>') {\n      return this.visit(node.left) > this.visit(node.right);\n    }\n    throw new InterpretError('Uknown operator: ' + node.operator, node);\n  }\n\n  visitLogicalExpression(node) {\n    if (node.operator === '||') {\n      return this.visit(node.left) || this.visit(node.right);\n    }\n    if (node.operator === '&&') {\n      return this.visit(node.left) && this.visit(node.right);\n    }\n    throw new InterpretError('Uknown operator: ' + node.operator, node);\n  };\n\n  visitIfStatement(node) {\n    if (this.visit(node.test)) {\n      return this.visit(node.consequence);\n    } else {\n      if (node.alternate) {\n        return this.visit(node.alternate);\n      }\n    }\n  };\n\n  visit(node) {\n    var method = 'visit' + node.type;\n    if (typeof this[method] === 'function') {\n      return this[method](node);\n    } else {\n      throw new Error('visit method \"' + method + '\" not found');\n    }\n  };\n\n  run(variables, callback) {\n\n    this.variables = {};\n    if (typeof variables == 'object') {\n      this.variables = variables;\n    }\n\n    this.callback = callback;\n\n    var nodes = this.parser.parse();\n    var result;\n    nodes.forEach(function(node) {\n      result = this.visit(node);\n    }.bind(this));\n    return result;\n\n  };\n\n};\n\nexport default Interpreter;\n","/**\n * Hemp\n *\n * Copyright ©2017 Dana Basken <dbasken@gmail.com>\n *\n */\nimport Parser from './Parser.js';\nimport Lexer from './Lexer.js';\nimport Interpreter from './Interpreter.js';\nimport ParseError from './ParseError.js';\nimport InterpretError from './InterpretError.js';\n\nclass Lala {\n\n  constructor() {\n\n    this.lexicon = {\n      ignore: {\n        startTest: /[ \\t\\n;]/,\n        test: /[ \\t\\n;]/\n      },\n      identifier: {\n        startTest: /[a-zA-Z]/,\n        test: /[a-zA-Z_\\.]/\n      },\n      number: {\n        startTest: /[0-9\\-]/,\n        test: /[0-9\\.]/\n      },\n      string : {\n        startTest: /[\"]/,\n        scanner: 'string'\n      },\n      operator: {\n        startTest: /[\\+\\-\\*\\/><=|&!]/,\n        test: /[\\+\\-\\*\\/><=|&!]/,\n        values: ['=', '+', '-', '*', '/', '==', '!=', '>=', '<=', '<', '>', '||', '&&']\n      },\n      parenthesis: {\n        startTest: /[\\(\\)]/\n      },\n      braces: {\n        startTest: /[{}]/\n      }\n    };\n\n    this.grammar = {\n      operators: [\n        {value: '+', result: 'MathExpression'},\n        {value: '-', result: 'MathExpression'},\n        {value: '*', result: 'MathExpression'},\n        {value: '/', result: 'MathExpression'},\n        {value: '==', result: 'ComparisonExpression'},\n        {value: '!=', result: 'ComparisonExpression'},\n        {value: '<=', result: 'ComparisonExpression'},\n        {value: '>=', result: 'ComparisonExpression'},\n        {value: '>', result: 'ComparisonExpression'},\n        {value: '<', result: 'ComparisonExpression'},\n        {value: '||', result: 'LogicalExpression'},\n        {value: '&&', result: 'LogicalExpression'},\n        {value: '=', result: 'AssignmentExpression'}\n      ],\n      expressions: [\n        {\n          result: 'IfStatement',\n          rules: [\n            {type: 'identifier', values: ['if']},\n            {type: 'parenthesis', value: '('},\n            {parse: 'term', result: 'test'},\n            {type: 'parenthesis', value: ')'},\n            {parse: 'expression', result: 'consequence'},\n            {type: 'identifier', values: ['else'], optional: true},\n            {parse: 'expression', result: 'alternate'}\n          ]\n        },\n        {\n          result: 'CallStatement',\n          rules: [\n            {type: 'identifier', values: ['hide', 'show']},\n            {type: 'parenthesis', value: '('},\n            {type: 'parenthesis', value: ')'}\n          ]\n        },\n        {\n          result: 'NativeFunction',\n          rules: [\n            {type: 'identifier', values: ['now', 'day', 'month', 'year']},\n            {type: 'parenthesis', value: '('},\n            {type: 'parenthesis', value: ')'}\n          ]\n        }\n      ]\n    };\n\n  };\n\n  check(text, variables) {\n    var lexer = new Lexer(this.lexicon, text);\n    var parser = new Parser(this.grammar, lexer);\n    return parser.parse();\n  };\n  \n  run(text, variables, callback) {\n    var lexer = new Lexer(this.lexicon, text);\n    var parser = new Parser(this.grammar, lexer);\n    var interpreter = new Interpreter(parser);\n    return {\n      returnValue: interpreter.run(variables, callback),\n      variables: interpreter.variables\n    };\n  }\n\n};\n\nLala.Parser = Parser;\nLala.Lexer = Lexer;\nLala.ParseError = ParseError;\nLala.InterpretError = InterpretError;\n\nexport default Lala;\n"],"names":["ParseError","message","token","expected","prototype","Error","Parser","grammar","lexer","nextToken","reset","JSON","parse","stringify","type","value","cloneCurrentToken","eat","start","end","result","expression","block","node","factor","foundOperator","i","operators","length","makeTermNode","expressions","rules","values","indexOf","j","rule","optional","term","nodes","push","program","Lexer","lexicon","text","pos","current","lex","peek","next","scanner","test","keepLast","c","types","Object","keys","startTest","scan","join","getToken","results","InterpretError","Interpreter","parser","Date","now","date","getDay","getMonth","getFullYear","callback","forEach","root","visit","bind","parseFloat","properties","split","object","variables","property","operator","left","right","isNaN","index","consequence","alternate","method","Lala","interpreter","run"],"mappings":"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"}